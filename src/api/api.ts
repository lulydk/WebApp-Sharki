/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Swagger Exercise
 * This is an Exercise server.  You can find  out more about Swagger at  [http://swagger.io](http://swagger.io) or on  [irc.freenode.net, #swagger](http://swagger.io/irc/). 
 *
 * OpenAPI spec version: 1.0.3
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:3000/api".replace(/\/+$/, "");
const TOKEN_STORAGE = 'token';
const EXERCISE_LIBRARY_NAME = '__exercises';

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected static get configuration(): Configuration {
        const token = window.localStorage.getItem(TOKEN_STORAGE) || "";
        return new Configuration({apiKey: token});
    }

    protected static basePath = BASE_PATH;

    protected static fetch = portableFetch;
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AuthenticationToken
 */
export interface AuthenticationToken {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationToken
     */
    token: string;
}

/**
 * 
 * @export
 * @interface Categories
 */
export interface Categories {
    /**
     * 
     * @type {number}
     * @memberof Categories
     */
    totalCount: number;
    /**
     * 
     * @type {string}
     * @memberof Categories
     */
    orderBy: string;
    /**
     * 
     * @type {string}
     * @memberof Categories
     */
    direction: Categories.DirectionEnum;
    /**
     * 
     * @type {Array<FullCategory>}
     * @memberof Categories
     */
    results: Array<FullCategory>;
    /**
     * 
     * @type {number}
     * @memberof Categories
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof Categories
     */
    page: number;
    /**
     * 
     * @type {boolean}
     * @memberof Categories
     */
    isLastPage: boolean;
}

/**
 * @export
 * @namespace Categories
 */
export namespace Categories {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    detail?: string;
}

/**
 * 
 * @export
 * @interface Credentials
 */
export class Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    password: string;

    constructor(username: string, password: string) {
        this.username = username;
        this.password = password;
    }
}

/**
 * 
 * @export
 * @interface Cycle
 */
export interface Cycle {
    /**
     * 
     * @type {string}
     * @memberof Cycle
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Cycle
     */
    detail: string;
    /**
     * 
     * @type {string}
     * @memberof Cycle
     */
    type: Cycle.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Cycle
     */
    order: number;
    /**
     * 
     * @type {number}
     * @memberof Cycle
     */
    repetitions: number;
}

/**
 * @export
 * @namespace Cycle
 */
export namespace Cycle {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Warmup = 'warmup',
        Exercise = 'exercise',
        Cooldown = 'cooldown'
    }
}

/**
 * 
 * @export
 * @interface Cycles
 */
export interface Cycles {
    /**
     * 
     * @type {number}
     * @memberof Cycles
     */
    totalCount: number;
    /**
     * 
     * @type {string}
     * @memberof Cycles
     */
    orderBy: string;
    /**
     * 
     * @type {string}
     * @memberof Cycles
     */
    direction: Cycles.DirectionEnum;
    /**
     * 
     * @type {Array<FullCycle>}
     * @memberof Cycles
     */
    results: Array<FullCycle>;
    /**
     * 
     * @type {number}
     * @memberof Cycles
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof Cycles
     */
    page: number;
    /**
     * 
     * @type {boolean}
     * @memberof Cycles
     */
    isLastPage: boolean;
}

/**
 * @export
 * @namespace Cycles
 */
export namespace Cycles {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface EmailConfirmation
 */
export interface EmailConfirmation {
    /**
     * 
     * @type {string}
     * @memberof EmailConfirmation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfirmation
     */
    code: string;
}

/**
 * 
 * @export
 * @interface EmailResend
 */
export interface EmailResend {
    /**
     * 
     * @type {string}
     * @memberof EmailResend
     */
    email: string;
}

/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Execution
 */
export interface Execution {
    /**
     * 
     * @type {number}
     * @memberof Execution
     */
    duration: number;
    /**
     * 
     * @type {boolean}
     * @memberof Execution
     */
    wasModified: boolean;
}

/**
 * 
 * @export
 * @interface Executions
 */
export interface Executions {
    /**
     * 
     * @type {number}
     * @memberof Executions
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Executions
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Executions
     */
    direction?: Executions.DirectionEnum;
    /**
     * 
     * @type {Array<FullExecution>}
     * @memberof Executions
     */
    results?: Array<FullExecution>;
    /**
     * 
     * @type {number}
     * @memberof Executions
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Executions
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Executions
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Executions
 */
export namespace Executions {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface Exercise
 */
export interface Exercise {
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    detail: string;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    type: Exercise.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Exercise
     */
    duration: number;
    /**
     * 
     * @type {number}
     * @memberof Exercise
     */
    repetitions: number;
    /**
     * 
     * @type {number}
     * @memberof Exercise
     */
    order?: number
}

/**
 * @export
 * @namespace Exercise
 */
export namespace Exercise {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Exercise = 'exercise',
        Rest = 'rest'
    }
}

/**
 * 
 * @export
 * @interface Exercises
 */
export interface Exercises {
    /**
     * 
     * @type {number}
     * @memberof Exercises
     */
    totalCount: number;
    /**
     * 
     * @type {string}
     * @memberof Exercises
     */
    orderBy: string;
    /**
     * 
     * @type {string}
     * @memberof Exercises
     */
    direction: Exercises.DirectionEnum;
    /**
     * 
     * @type {Array<FullExercise>}
     * @memberof Exercises
     */
    results: Array<FullExercise>;
    /**
     * 
     * @type {number}
     * @memberof Exercises
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof Exercises
     */
    page: number;
    /**
     * 
     * @type {boolean}
     * @memberof Exercises
     */
    isLastPage: boolean;
}

/**
 * @export
 * @namespace Exercises
 */
export namespace Exercises {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface Favourites
 */
export interface Favourites {
    /**
     * 
     * @type {number}
     * @memberof Favourites
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Favourites
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Favourites
     */
    direction?: Favourites.DirectionEnum;
    /**
     * 
     * @type {Array<FullRoutine>}
     * @memberof Favourites
     */
    results?: Array<FullRoutine>;
    /**
     * 
     * @type {number}
     * @memberof Favourites
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Favourites
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Favourites
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Favourites
 */
export namespace Favourites {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface FullCategory
 */
export interface FullCategory extends Category{
    /**
     * 
     * @type {number}
     * @memberof FullCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FullCategory
     */
    detail?: string;
}

/**
 * 
 * @export
 * @interface FullCycle
 */
export interface FullCycle extends Cycle {
    /**
     * 
     * @type {number}
     * @memberof FullCycle
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullCycle
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FullCycle
     */
    detail: string;
    /**
     * 
     * @type {string}
     * @memberof FullCycle
     */
    type: FullCycle.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FullCycle
     */
    order: number;
    /**
     * 
     * @type {number}
     * @memberof FullCycle
     */
    repetitions: number;
}

/**
 * @export
 * @namespace FullCycle
 */
export namespace FullCycle {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Warmup = 'warmup',
        Exercise = 'exercise',
        Cooldown = 'cooldown'
    }
}

/**
 * 
 * @export
 * @interface FullExecution
 */
export interface FullExecution extends Execution {
    /**
     * 
     * @type {number}
     * @memberof FullExecution
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FullExecution
     */
    date: number;
    /**
     * 
     * @type {number}
     * @memberof FullExecution
     */
    duration: number;
    /**
     * 
     * @type {boolean}
     * @memberof FullExecution
     */
    wasModified: boolean;
    /**
     * 
     * @type {FullRoutine}
     * @memberof FullExecution
     */
    routine: FullRoutine;
}

/**
 * 
 * @export
 * @interface FullExercise
 */
export interface FullExercise extends Exercise {
    /**
     * 
     * @type {number}
     * @memberof FullExercise
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullExercise
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FullExercise
     */
    detail: string;
    /**
     * 
     * @type {string}
     * @memberof FullExercise
     */
    type: FullExercise.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FullExercise
     */
    duration: number;
    /**
     * 
     * @type {number}
     * @memberof FullExercise
     */
    repetitions: number;
    /**
     * 
     * @type {number}
     * @memberof FullExercise
     */
    order: number;
}

/**
 * @export
 * @namespace FullExercise
 */
export namespace FullExercise {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Exercise = 'exercise',
        Rest = 'rest'
    }
}

/**
 * 
 * @export
 * @interface FullImage
 */
export interface FullImage extends Image {
    /**
     * 
     * @type {number}
     * @memberof FullImage
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FullImage
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof FullImage
     */
    url: string;
}

/**
 * 
 * @export
 * @interface FullRating
 */
export interface FullRating extends Rating {
    /**
     * 
     * @type {number}
     * @memberof FullRating
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FullRating
     */
    date: number;
    /**
     * 
     * @type {number}
     * @memberof FullRating
     */
    score: number;
    /**
     * 
     * @type {string}
     * @memberof FullRating
     */
    review: string;
    /**
     * 
     * @type {FullRoutine}
     * @memberof FullRating
     */
    routine: FullRoutine;
}

/**
 * 
 * @export
 * @interface FullRoutine
 */
export interface FullRoutine extends Routine{
    /**
     * 
     * @type {number}
     * @memberof FullRoutine
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullRoutine
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FullRoutine
     */
    detail: string;
    /**
     * 
     * @type {number}
     * @memberof FullRoutine
     */
    dateCreated: number;
    /**
     * 
     * @type {number}
     * @memberof FullRoutine
     */
    averageRating: number;
    /**
     * 
     * @type {boolean}
     * @memberof FullRoutine
     */
    isPublic: boolean;
    /**
     * 
     * @type {string}
     * @memberof FullRoutine
     */
    difficulty: FullRoutine.DifficultyEnum;
    /**
     * 
     * @type {FullCategory}
     * @memberof FullRoutine
     */
    category: FullCategory;
    /**
     * 
     * @type {PublicUser}
     * @memberof FullRoutine
     */
    creator: PublicUser;
}

/**
 * @export
 * @namespace FullRoutine
 */
export namespace FullRoutine {
    /**
     * @export
     * @enum {string}
     */
    export enum DifficultyEnum {
        Rookie = 'rookie',
        Beginner = 'beginner',
        Intermediate = 'intermediate',
        Advanced = 'advanced',
        Expert = 'expert'
    }
}

/**
 * 
 * @export
 * @interface FullSport
 */
export interface FullSport extends Sport {
    /**
     * 
     * @type {number}
     * @memberof FullSport
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullSport
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FullSport
     */
    detail?: string;
}

/**
 * 
 * @export
 * @interface FullUser
 */
export interface FullUser extends User {
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    gender: FullUser.GenderEnum;
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    birthdate: number;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    phone?: string;
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    dateCreated: number;
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    dateLastActive: number;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    deleted: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    verified: boolean;
}

/**
 * @export
 * @namespace FullUser
 */
export namespace FullUser {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Male = 'male',
        Female = 'female',
        Other = 'other'
    }
}

/**
 * 
 * @export
 * @interface FullVideo
 */
export interface FullVideo extends Video {
    /**
     * 
     * @type {number}
     * @memberof FullVideo
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FullVideo
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof FullVideo
     */
    url: string;
}

/**
 * 
 * @export
 * @interface FullWeighting
 */
export interface FullWeighting extends Weighting {
    /**
     * 
     * @type {number}
     * @memberof FullWeighting
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FullWeighting
     */
    date: number;
    /**
     * 
     * @type {number}
     * @memberof FullWeighting
     */
    weight: number;
    /**
     * 
     * @type {number}
     * @memberof FullWeighting
     */
    height: number;
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    url: string;
}

/**
 * 
 * @export
 * @interface Images
 */
export interface Images {
    /**
     * 
     * @type {number}
     * @memberof Images
     */
    totalCount: number;
    /**
     * 
     * @type {string}
     * @memberof Images
     */
    orderBy: string;
    /**
     * 
     * @type {string}
     * @memberof Images
     */
    direction: Images.DirectionEnum;
    /**
     * 
     * @type {Array<FullImage>}
     * @memberof Images
     */
    results: Array<FullImage>;
    /**
     * 
     * @type {number}
     * @memberof Images
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof Images
     */
    page: number;
    /**
     * 
     * @type {boolean}
     * @memberof Images
     */
    isLastPage: boolean;
}

/**
 * @export
 * @namespace Images
 */
export namespace Images {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * 
     * @type {Array<ErrorDetails>}
     * @memberof ModelError
     */
    details?: Array<ErrorDetails>;
}

/**
 * 
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    gender: PublicUser.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    avatarUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    dateCreated: number;
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    dateLastActive: number;
}

/**
 * @export
 * @namespace PublicUser
 */
export namespace PublicUser {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Male = 'male',
        Female = 'female',
        Other = 'other'
    }
}

/**
 * 
 * @export
 * @interface Rating
 */
export interface Rating {
    /**
     * 
     * @type {number}
     * @memberof Rating
     */
    score: number;
    /**
     * 
     * @type {string}
     * @memberof Rating
     */
    review: string;
}

/**
 * 
 * @export
 * @interface Ratings
 */
export interface Ratings {
    /**
     * 
     * @type {number}
     * @memberof Ratings
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Ratings
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ratings
     */
    direction?: Ratings.DirectionEnum;
    /**
     * 
     * @type {Array<FullRating>}
     * @memberof Ratings
     */
    results?: Array<FullRating>;
    /**
     * 
     * @type {number}
     * @memberof Ratings
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Ratings
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ratings
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Ratings
 */
export namespace Ratings {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface Routine
 */
export interface Routine {
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    detail: string;
    /**
     * 
     * @type {number}
     * @memberof Routine
     */
    dateCreated?: number;
    /**
     * 
     * @type {number}
     * @memberof Routine
     */
    averageRating?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Routine
     */
    isPublic: boolean;
    /**
     * 
     * @type {RoutineCategory}
     * @memberof Routine
     */
    category: RoutineCategory;
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    difficulty: Routine.DifficultyEnum;
}

/**
 * @export
 * @namespace Routine
 */
export namespace Routine {
    /**
     * @export
     * @enum {string}
     */
    export enum DifficultyEnum {
        Rookie = 'rookie',
        Beginner = 'beginner',
        Intermediate = 'intermediate',
        Advanced = 'advanced',
        Expert = 'expert'
    }
}

/**
 * 
 * @export
 * @interface RoutineCategory
 */
export interface RoutineCategory {
    /**
     * 
     * @type {number}
     * @memberof RoutineCategory
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface Routines
 */
export interface Routines {
    /**
     * 
     * @type {number}
     * @memberof Routines
     */
    totalCount: number;
    /**
     * 
     * @type {string}
     * @memberof Routines
     */
    orderBy: string;
    /**
     * 
     * @type {string}
     * @memberof Routines
     */
    direction: Routines.DirectionEnum;
    /**
     * 
     * @type {Array<FullRoutine>}
     * @memberof Routines
     */
    results: Array<FullRoutine>;
    /**
     * 
     * @type {number}
     * @memberof Routines
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof Routines
     */
    page: number;
    /**
     * 
     * @type {boolean}
     * @memberof Routines
     */
    isLastPage: boolean;
}

/**
 * @export
 * @namespace Routines
 */
export namespace Routines {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @class Sport
 */
export interface Sport {
    /**
     * 
     * @type {string}
     * @memberof Sport
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Sport
     */
    detail?: string;
}

/**
 * 
 * @export
 * @interface Sports
 */
export interface Sports {
    /**
     * 
     * @type {number}
     * @memberof Sports
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Sports
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Sports
     */
    direction?: Sports.DirectionEnum;
    /**
     * 
     * @type {Array<FullSport>}
     * @memberof Sports
     */
    results?: Array<FullSport>;
    /**
     * 
     * @type {number}
     * @memberof Sports
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Sports
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Sports
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Sports
 */
export namespace Sports {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    birthdate: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    gender: User.GenderEnum;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Male = 'male',
        Female = 'female',
        Other = 'other'
    }
}

/**
 * 
 * @export
 * @interface UserWithoutPassword
 */
export interface UserWithoutPassword {
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof UserWithoutPassword
     */
    birthdate: number;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithoutPassword
     */
    gender: UserWithoutPassword.GenderEnum;
}

/**
 * @export
 * @namespace UserWithoutPassword
 */
export namespace UserWithoutPassword {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Male = 'male',
        Female = 'female',
        Other = 'other'
    }
}

/**
 * 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    url: string;
}

/**
 * 
 * @export
 * @interface Videos
 */
export interface Videos {
    /**
     * 
     * @type {number}
     * @memberof Videos
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Videos
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Videos
     */
    direction?: Videos.DirectionEnum;
    /**
     * 
     * @type {Array<FullVideo>}
     * @memberof Videos
     */
    results?: Array<FullVideo>;
    /**
     * 
     * @type {number}
     * @memberof Videos
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Videos
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Videos
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Videos
 */
export namespace Videos {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * 
 * @export
 * @interface Weighting
 */
export interface Weighting {
    /**
     * 
     * @type {number}
     * @memberof Weighting
     */
    weight: number;
    /**
     * 
     * @type {number}
     * @memberof Weighting
     */
    height: number;
}

/**
 * 
 * @export
 * @interface Weightings
 */
export interface Weightings {
    /**
     * 
     * @type {number}
     * @memberof Weightings
     */
    totalCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Weightings
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Weightings
     */
    direction?: Weightings.DirectionEnum;
    /**
     * 
     * @type {Array<FullWeighting>}
     * @memberof Weightings
     */
    results?: Array<FullWeighting>;
    /**
     * 
     * @type {number}
     * @memberof Weightings
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof Weightings
     */
    page?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Weightings
     */
    isLastPage?: boolean;
}

/**
 * @export
 * @namespace Weightings
 */
export namespace Weightings {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

export interface ExerciseImageCombo {
    exercise: Exercise;
    image: Image | null;
}

export interface FullExerciseImageCombo extends ExerciseImageCombo{
    exercise: FullExercise;
    image: FullImage | null;
}


/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
export const CategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create category
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(body: Category, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addCategory.');
            }
            const localVarPath = `/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Category" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve categories
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategories(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategory.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update category
         * @param {number} categoryId Category identifier
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryId: number, body: Category, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling updateCategory.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCategory.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Category" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create category
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(body: Category, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullCategory> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).addCategory(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).deleteCategory(categoryId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve categories
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategories(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Categories> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).findCategories(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullCategory> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategory(categoryId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update category
         * @param {number} categoryId Category identifier
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryId: number, body: Category, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullCategory> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).updateCategory(categoryId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create category
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(body: Category, options?: any) {
            return CategoriesApiFp(configuration).addCategory(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options?: any) {
            return CategoriesApiFp(configuration).deleteCategory(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve categories
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategories(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
            return CategoriesApiFp(configuration).findCategories(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve category
         * @param {number} categoryId Category identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: number, options?: any) {
            return CategoriesApiFp(configuration).getCategory(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update category
         * @param {number} categoryId Category identifier
         * @param {Category} body Category information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryId: number, body: Category, options?: any) {
            return CategoriesApiFp(configuration).updateCategory(categoryId, body, options)(fetch, basePath);
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create category
     * @param {Category} body Category information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public static addCategory(body: Category, options?: any) {
        return CategoriesApiFp(this.configuration).addCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete category
     * @param {number} categoryId Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public static  deleteCategory(categoryId: number, options?: any) {
        return CategoriesApiFp(this.configuration).deleteCategory(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve categories
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public static findCategories(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
        return CategoriesApiFp(this.configuration).findCategories(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve category
     * @param {number} categoryId Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public static getCategory(categoryId: number, options?: any) {
        return CategoriesApiFp(this.configuration).getCategory(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update category
     * @param {number} categoryId Category identifier
     * @param {Category} body Category information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public static updateCategory(categoryId: number, body: Category, options?: any) {
        return CategoriesApiFp(this.configuration).updateCategory(categoryId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * CyclesApi - fetch parameter creator
 * @export
 */
export const CyclesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle
         * @param {number} routineId Routine identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCycle(routineId: number, body: Cycle, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addCycle.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addCycle.');
            }
            const localVarPath = `/routines/{routineId}/cycles`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cycle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCycle(routineId: number, cycleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling deleteCycle.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling deleteCycle.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycles
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCycles(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findCycles.');
            }
            const localVarPath = `/routines/{routineId}/cycles`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleCycle(routineId: number, cycleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findSingleCycle.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findSingleCycle.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCycle(routineId: number, cycleId: number, body: Cycle, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling updateCycle.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling updateCycle.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCycle.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cycle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CyclesApi - functional programming interface
 * @export
 */
export const CyclesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle
         * @param {number} routineId Routine identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCycle(routineId: number, body: Cycle, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullCycle> {
            const localVarFetchArgs = CyclesApiFetchParamCreator(configuration).addCycle(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCycle(routineId: number, cycleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CyclesApiFetchParamCreator(configuration).deleteCycle(routineId, cycleId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycles
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCycles(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cycles> {
            const localVarFetchArgs = CyclesApiFetchParamCreator(configuration).findCycles(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleCycle(routineId: number, cycleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullCycle> {
            const localVarFetchArgs = CyclesApiFetchParamCreator(configuration).findSingleCycle(routineId, cycleId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCycle(routineId: number, cycleId: number, body: Cycle, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cycle> {
            const localVarFetchArgs = CyclesApiFetchParamCreator(configuration).updateCycle(routineId, cycleId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * CyclesApi - factory interface
 * @export
 */
export const CyclesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine cycle
         * @param {number} routineId Routine identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCycle(routineId: number, body: Cycle, options?: any) {
            return CyclesApiFp(configuration).addCycle(routineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCycle(routineId: number, cycleId: number, options?: any) {
            return CyclesApiFp(configuration).deleteCycle(routineId, cycleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycles
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCycles(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions', direction?: 'asc' | 'desc', options?: any) {
            return CyclesApiFp(configuration).findCycles(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleCycle(routineId: number, cycleId: number, options?: any) {
            return CyclesApiFp(configuration).findSingleCycle(routineId, cycleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update routine cycle
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Cycle} body Cycle information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCycle(routineId: number, cycleId: number, body: Cycle, options?: any) {
            return CyclesApiFp(configuration).updateCycle(routineId, cycleId, body, options)(fetch, basePath);
        },
    };
};

/**
 * CyclesApi - object-oriented interface
 * @export
 * @class CyclesApi
 * @extends {BaseAPI}
 */
export class CyclesApi extends BaseAPI {
    /**
     * 
     * @summary Create routine cycle
     * @param {number} routineId Routine identifier
     * @param {Cycle} body Cycle information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclesApi
     */
    public static addCycle(routineId: number, body: Cycle, options?: any) {
        return CyclesApiFp(this.configuration).addCycle(routineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine cycle
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclesApi
     */
    public static deleteCycle(routineId: number, cycleId: number, options?: any) {
        return CyclesApiFp(this.configuration).deleteCycle(routineId, cycleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycles
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclesApi
     */
    public static findCycles(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'order' | 'repetitions', direction?: 'asc' | 'desc', options?: any) {
        return CyclesApiFp(this.configuration).findCycles(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclesApi
     */
    public static findSingleCycle(routineId: number, cycleId: number, options?: any) {
        return CyclesApiFp(this.configuration).findSingleCycle(routineId, cycleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update routine cycle
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {Cycle} body Cycle information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclesApi
     */
    public static updateCycle(routineId: number, cycleId: number, body: Cycle, options?: any) {
        return CyclesApiFp(this.configuration).updateCycle(routineId, cycleId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ExecutionsApi - fetch parameter creator
 * @export
 */
export const ExecutionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addExecution.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addExecution.');
            }
            const localVarPath = `/routines/{routineId}/executions`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Execution" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findExecutions.');
            }
            const localVarPath = `/routines/{routineId}/executions`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionsApi - functional programming interface
 * @export
 */
export const ExecutionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullExecution> {
            const localVarFetchArgs = ExecutionsApiFetchParamCreator(configuration).addExecution(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Executions> {
            const localVarFetchArgs = ExecutionsApiFetchParamCreator(configuration).findExecutions(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * ExecutionsApi - factory interface
 * @export
 */
export const ExecutionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options?: any) {
            return ExecutionsApiFp(configuration).addExecution(routineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
            return ExecutionsApiFp(configuration).findExecutions(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
    };
};

/**
 * ExecutionsApi - object-oriented interface
 * @export
 * @class ExecutionsApi
 * @extends {BaseAPI}
 */
export class ExecutionsApi extends BaseAPI {
    /**
     * 
     * @summary Create routine execution
     * @param {number} routineId Routine identifier
     * @param {Execution} body Execution information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionsApi
     */
    public static addExecution(routineId: number, body: Execution, options?: any) {
        return ExecutionsApiFp(this.configuration).addExecution(routineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine executions
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionsApi
     */
    public static findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
        return ExecutionsApiFp(this.configuration).findExecutions(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

}

/**
 * ExercisesApi - fetch parameter creator
 * @export
 */
export const ExercisesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExercise(routineId: number, cycleId: number, body: Exercise, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addExercise.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling addExercise.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addExercise.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Exercise" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(routineId: number, cycleId: number, exerciseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling deleteExercise.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling deleteExercise.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling deleteExercise.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercises
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExercises(routineId: number, cycleId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findExercises.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findExercises.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExercise(routineId: number, cycleId: number, exerciseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findSingleExercise.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findSingleExercise.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling findSingleExercise.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(routineId: number, cycleId: number, exerciseId: number, body: Exercise, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling updateExercise.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling updateExercise.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling updateExercise.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExercise.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Exercise" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExercisesApi - functional programming interface
 * @export
 */
export const ExercisesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExercise(routineId: number, cycleId: number, body: Exercise, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullExercise> {
            const localVarFetchArgs = ExercisesApiFetchParamCreator(configuration).addExercise(routineId, cycleId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(routineId: number, cycleId: number, exerciseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExercisesApiFetchParamCreator(configuration).deleteExercise(routineId, cycleId, exerciseId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercises
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExercises(routineId: number, cycleId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Exercises> {
            const localVarFetchArgs = ExercisesApiFetchParamCreator(configuration).findExercises(routineId, cycleId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExercise(routineId: number, cycleId: number, exerciseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullExercise> {
            const localVarFetchArgs = ExercisesApiFetchParamCreator(configuration).findSingleExercise(routineId, cycleId, exerciseId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(routineId: number, cycleId: number, exerciseId: number, body: Exercise, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullExercise> {
            const localVarFetchArgs = ExercisesApiFetchParamCreator(configuration).updateExercise(routineId, cycleId, exerciseId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * ExercisesApi - factory interface
 * @export
 */
export const ExercisesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExercise(routineId: number, cycleId: number, body: Exercise, options?: any) {
            return ExercisesApiFp(configuration).addExercise(routineId, cycleId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(routineId: number, cycleId: number, exerciseId: number, options?: any) {
            return ExercisesApiFp(configuration).deleteExercise(routineId, cycleId, exerciseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercises
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExercises(routineId: number, cycleId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration', direction?: 'asc' | 'desc', options?: any) {
            return ExercisesApiFp(configuration).findExercises(routineId, cycleId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExercise(routineId: number, cycleId: number, exerciseId: number, options?: any) {
            return ExercisesApiFp(configuration).findSingleExercise(routineId, cycleId, exerciseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update routine cycle exercise
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Exercise} body Exercise information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(routineId: number, cycleId: number, exerciseId: number, body: Exercise, options?: any) {
            return ExercisesApiFp(configuration).updateExercise(routineId, cycleId, exerciseId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ExercisesApi - object-oriented interface
 * @export
 * @class ExercisesApi
 * @extends {BaseAPI}
 */
export class ExercisesApi extends BaseAPI {
    /**
     * 
     * @summary Create routine cycle exercise
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {Exercise} body Exercise information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public static addExercise(routineId: number, cycleId: number, body: Exercise, options?: any) {
        return ExercisesApiFp(this.configuration).addExercise(routineId, cycleId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine cycle exercise
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public static deleteExercise(routineId: number, cycleId: number, exerciseId: number, options?: any) {
        return ExercisesApiFp(this.configuration).deleteExercise(routineId, cycleId, exerciseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercises
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public static findExercises(routineId: number, cycleId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration', direction?: 'asc' | 'desc', options?: any) {
        return ExercisesApiFp(this.configuration).findExercises(routineId, cycleId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercise
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public static findSingleExercise(routineId: number, cycleId: number, exerciseId: number, options?: any) {
        return ExercisesApiFp(this.configuration).findSingleExercise(routineId, cycleId, exerciseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update routine cycle exercise
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {Exercise} body Exercise information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public static updateExercise(routineId: number, cycleId: number, exerciseId: number, body: Exercise, options?: any) {
        return ExercisesApiFp(this.configuration).updateExercise(routineId, cycleId, exerciseId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ImagesApi - fetch parameter creator
 * @export
 */
export const ImagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseImage(routineId: number, cycleId: number, exerciseId: number, body: Image, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addExerciseImage.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling addExerciseImage.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling addExerciseImage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addExerciseImage.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/images`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Image" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling deleteExerciseImage.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling deleteExerciseImage.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling deleteExerciseImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling deleteExerciseImage.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/images/{imageId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise images
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseImages(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findExerciseImages.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findExerciseImages.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling findExerciseImages.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/images`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findSingleExerciseImage.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findSingleExerciseImage.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling findSingleExerciseImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling findSingleExerciseImage.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/images/{imageId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, body: Image, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling updateExerciseImage.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling updateExerciseImage.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling updateExerciseImage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling updateExerciseImage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExerciseImage.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/images/{imageId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Image" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseImage(routineId: number, cycleId: number, exerciseId: number, body: Image, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullImage> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).addExerciseImage(routineId, cycleId, exerciseId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).deleteExerciseImage(routineId, cycleId, exerciseId, imageId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise images
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseImages(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Images> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).findExerciseImages(routineId, cycleId, exerciseId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullImage> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).findSingleExerciseImage(routineId, cycleId, exerciseId, imageId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, body: Image, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullImage> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).updateExerciseImage(routineId, cycleId, exerciseId, imageId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseImage(routineId: number, cycleId: number, exerciseId: number, body: Image, options?: any) {
            return ImagesApiFp(configuration).addExerciseImage(routineId, cycleId, exerciseId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any) {
            return ImagesApiFp(configuration).deleteExerciseImage(routineId, cycleId, exerciseId, imageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise images
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseImages(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any) {
            return ImagesApiFp(configuration).findExerciseImages(routineId, cycleId, exerciseId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any) {
            return ImagesApiFp(configuration).findSingleExerciseImage(routineId, cycleId, exerciseId, imageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update routine cycle exercise image
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} imageId Image identifier
         * @param {Image} body Image information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, body: Image, options?: any) {
            return ImagesApiFp(configuration).updateExerciseImage(routineId, cycleId, exerciseId, imageId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Create routine cycle exercise image
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {Image} body Image information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public static addExerciseImage(routineId: number, cycleId: number, exerciseId: number, body: Image, options?: any) {
        return ImagesApiFp(this.configuration).addExerciseImage(routineId, cycleId, exerciseId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine cycle exercise image
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} imageId Image identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public static deleteExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any) {
        return ImagesApiFp(this.configuration).deleteExerciseImage(routineId, cycleId, exerciseId, imageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercise images
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'number' | 'url'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public static findExerciseImages(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any) {
        return ImagesApiFp(this.configuration).findExerciseImages(routineId, cycleId, exerciseId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercise image
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} imageId Image identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public static findSingleExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, options?: any) {
        return ImagesApiFp(this.configuration).findSingleExerciseImage(routineId, cycleId, exerciseId, imageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update routine cycle exercise image
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} imageId Image identifier
     * @param {Image} body Image information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public static updateExerciseImage(routineId: number, cycleId: number, exerciseId: number, imageId: number, body: Image, options?: any) {
        return ImagesApiFp(this.configuration).updateExerciseImage(routineId, cycleId, exerciseId, imageId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RatingsApi - fetch parameter creator
 * @export
 */
export const RatingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addRating.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addRating.');
            }
            const localVarPath = `/routines/{routineId}/ratings`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Rating" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findRatings.');
            }
            const localVarPath = `/routines/{routineId}/ratings`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingsApi - functional programming interface
 * @export
 */
export const RatingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullRating> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).addRating(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ratings> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).findRatings(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * RatingsApi - factory interface
 * @export
 */
export const RatingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options?: any) {
            return RatingsApiFp(configuration).addRating(routineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
            return RatingsApiFp(configuration).findRatings(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
    };
};

/**
 * RatingsApi - object-oriented interface
 * @export
 * @class RatingsApi
 * @extends {BaseAPI}
 */
export class RatingsApi extends BaseAPI {
    /**
     * 
     * @summary Create routine rating
     * @param {number} routineId Routine identifier
     * @param {Rating} body Rating information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public static addRating(routineId: number, body: Rating, options?: any) {
        return RatingsApiFp(this.configuration).addRating(routineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine ratings
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'score'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public static findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
        return RatingsApiFp(this.configuration).findRatings(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

}

/**
 * RoutinesApi - fetch parameter creator
 * @export
 */
export const RoutinesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addExecution.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addExecution.');
            }
            const localVarPath = `/routines/{routineId}/executions`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Execution" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addRating.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addRating.');
            }
            const localVarPath = `/routines/{routineId}/ratings`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Rating" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create routine
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoutine(body: Routine, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addRoutine.');
            }
            const localVarPath = `/routines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Routine" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateRoutineSport(routineId: number, sportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling associateRoutineSport.');
            }
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling associateRoutineSport.');
            }
            const localVarPath = `/routines/{routineId}/sport/{sportId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutine(routineId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling deleteRoutine.');
            }
            const localVarPath = `/routines/{routineId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling dissociateRoutineSport.');
            }
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling dissociateRoutineSport.');
            }
            const localVarPath = `/routines/{routineId}/sport/{sportId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findExecutions.');
            }
            const localVarPath = `/routines/{routineId}/executions`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findRatings.');
            }
            const localVarPath = `/routines/{routineId}/ratings`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routines
         * @param {string} [search] Search filter
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRoutines(search?: string, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/routines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutine(routineId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling getRoutine.');
            }
            const localVarPath = `/routines/{routineId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine sports
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutineSports(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling getRoutineSports.');
            }
            const localVarPath = `/routines/{routineId}/sport`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update routine
         * @param {number} routineId Routine identifier
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoutine(routineId: number, body: Routine, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling updateRoutine.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRoutine.');
            }
            const localVarPath = `/routines/{routineId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Routine" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutinesApi - functional programming interface
 * @export
 */
export const RoutinesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullExecution> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).addExecution(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullRating> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).addRating(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Create routine
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoutine(body: Routine, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullRoutine> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).addRoutine(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Create routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateRoutineSport(routineId: number, sportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).associateRoutineSport(routineId, sportId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutine(routineId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).deleteRoutine(routineId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).dissociateRoutineSport(routineId, sportId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Executions> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).findExecutions(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ratings> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).findRatings(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routines
         * @param {string} [search] Search filter
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRoutines(search?: string, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Routines> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).findRoutines(search, difficulty, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutine(routineId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullRoutine> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).getRoutine(routineId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine sports
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutineSports(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Sports> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).getRoutineSports(routineId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update routine
         * @param {number} routineId Routine identifier
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoutine(routineId: number, body: Routine, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullRoutine> {
            const localVarFetchArgs = RoutinesApiFetchParamCreator(configuration).updateRoutine(routineId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * RoutinesApi - factory interface
 * @export
 */
export const RoutinesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine execution
         * @param {number} routineId Routine identifier
         * @param {Execution} body Execution information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExecution(routineId: number, body: Execution, options?: any) {
            return RoutinesApiFp(configuration).addExecution(routineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create routine rating
         * @param {number} routineId Routine identifier
         * @param {Rating} body Rating information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(routineId: number, body: Rating, options?: any) {
            return RoutinesApiFp(configuration).addRating(routineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create routine
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoutine(body: Routine, options?: any) {
            return RoutinesApiFp(configuration).addRoutine(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateRoutineSport(routineId: number, sportId: number, options?: any) {
            return RoutinesApiFp(configuration).associateRoutineSport(routineId, sportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutine(routineId: number, options?: any) {
            return RoutinesApiFp(configuration).deleteRoutine(routineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options?: any) {
            return RoutinesApiFp(configuration).dissociateRoutineSport(routineId, sportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine executions
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
            return RoutinesApiFp(configuration).findExecutions(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine ratings
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
            return RoutinesApiFp(configuration).findRatings(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routines
         * @param {string} [search] Search filter
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRoutines(search?: string, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
            return RoutinesApiFp(configuration).findRoutines(search, difficulty, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutine(routineId: number, options?: any) {
            return RoutinesApiFp(configuration).getRoutine(routineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine sports
         * @param {number} routineId Routine identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutineSports(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
            return RoutinesApiFp(configuration).getRoutineSports(routineId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update routine
         * @param {number} routineId Routine identifier
         * @param {Routine} body Routine information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoutine(routineId: number, body: Routine, options?: any) {
            return RoutinesApiFp(configuration).updateRoutine(routineId, body, options)(fetch, basePath);
        },
    };
};

/**
 * RoutinesApi - object-oriented interface
 * @export
 * @class RoutinesApi
 * @extends {BaseAPI}
 */
export class RoutinesApi extends BaseAPI {
    /**
     * 
     * @summary Create routine execution
     * @param {number} routineId Routine identifier
     * @param {Execution} body Execution information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static addExecution(routineId: number, body: Execution, options?: any) {
        return RoutinesApiFp(this.configuration).addExecution(routineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create routine rating
     * @param {number} routineId Routine identifier
     * @param {Rating} body Rating information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static addRating(routineId: number, body: Rating, options?: any) {
        return RoutinesApiFp(this.configuration).addRating(routineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create routine
     * @param {Routine} body Routine information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static addRoutine(body: Routine, options?: any) {
        return RoutinesApiFp(this.configuration).addRoutine(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create routine sport
     * @param {number} routineId Routine identifier
     * @param {number} sportId Sport identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static associateRoutineSport(routineId: number, sportId: number, options?: any) {
        return RoutinesApiFp(this.configuration).associateRoutineSport(routineId, sportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine
     * @param {number} routineId Routine identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static deleteRoutine(routineId: number, options?: any) {
        return RoutinesApiFp(this.configuration).deleteRoutine(routineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine sport
     * @param {number} routineId Routine identifier
     * @param {number} sportId Sport identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static dissociateRoutineSport(routineId: number, sportId: number, options?: any) {
        return RoutinesApiFp(this.configuration).dissociateRoutineSport(routineId, sportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine executions
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static findExecutions(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
        return RoutinesApiFp(this.configuration).findExecutions(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine ratings
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'score'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static findRatings(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
        return RoutinesApiFp(this.configuration).findRatings(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routines
     * @param {string} [search] Search filter
     * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static findRoutines(search?: string, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
        return RoutinesApiFp(this.configuration).findRoutines(search, difficulty, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine
     * @param {number} routineId Routine identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static getRoutine(routineId: number, options?: any) {
        return RoutinesApiFp(this.configuration).getRoutine(routineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine sports
     * @param {number} routineId Routine identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static getRoutineSports(routineId: number, page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
        return RoutinesApiFp(this.configuration).getRoutineSports(routineId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update routine
     * @param {number} routineId Routine identifier
     * @param {Routine} body Routine information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutinesApi
     */
    public static updateRoutine(routineId: number, body: Routine, options?: any) {
        return RoutinesApiFp(this.configuration).updateRoutine(routineId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * SportsApi - fetch parameter creator
 * @export
 */
export const SportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create sport
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSport(body: Sport, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addSport.');
            }
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Sport" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSport(sportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling deleteSport.');
            }
            const localVarPath = `/sports/{sportId}`
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling dissociateRoutineSport.');
            }
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling dissociateRoutineSport.');
            }
            const localVarPath = `/routines/{routineId}/sport/{sportId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve sports
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSports(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSport(sportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling getSport.');
            }
            const localVarPath = `/sports/{sportId}`
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update sport
         * @param {number} sportId Sport identifier
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSport(sportId: number, body: Sport, options: any = {}): FetchArgs {
            // verify required parameter 'sportId' is not null or undefined
            if (sportId === null || sportId === undefined) {
                throw new RequiredError('sportId','Required parameter sportId was null or undefined when calling updateSport.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSport.');
            }
            const localVarPath = `/sports/{sportId}`
                .replace(`{${"sportId"}}`, encodeURIComponent(String(sportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Sport" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SportsApi - functional programming interface
 * @export
 */
export const SportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create sport
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSport(body: Sport, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullSport> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).addSport(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSport(sportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).deleteSport(sportId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).dissociateRoutineSport(routineId, sportId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve sports
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSports(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Sports> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).findSports(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSport(sportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullSport> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).getSport(sportId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update sport
         * @param {number} sportId Sport identifier
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSport(sportId: number, body: Sport, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullSport> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).updateSport(sportId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * SportsApi - factory interface
 * @export
 */
export const SportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create sport
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSport(body: Sport, options?: any) {
            return SportsApiFp(configuration).addSport(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSport(sportId: number, options?: any) {
            return SportsApiFp(configuration).deleteSport(sportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine sport
         * @param {number} routineId Routine identifier
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dissociateRoutineSport(routineId: number, sportId: number, options?: any) {
            return SportsApiFp(configuration).dissociateRoutineSport(routineId, sportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve sports
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSports(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
            return SportsApiFp(configuration).findSports(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve sport
         * @param {number} sportId Sport identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSport(sportId: number, options?: any) {
            return SportsApiFp(configuration).getSport(sportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update sport
         * @param {number} sportId Sport identifier
         * @param {Sport} body Sport information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSport(sportId: number, body: Sport, options?: any) {
            return SportsApiFp(configuration).updateSport(sportId, body, options)(fetch, basePath);
        },
    };
};

/**
 * SportsApi - object-oriented interface
 * @export
 * @class SportsApi
 * @extends {BaseAPI}
 */
export class SportsApi extends BaseAPI {
    /**
     * 
     * @summary Create sport
     * @param {Sport} body Sport information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static addSport(body: Sport, options?: any) {
        return SportsApiFp(this.configuration).addSport(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete sport
     * @param {number} sportId Sport identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static deleteSport(sportId: number, options?: any) {
        return SportsApiFp(this.configuration).deleteSport(sportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine sport
     * @param {number} routineId Routine identifier
     * @param {number} sportId Sport identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static dissociateRoutineSport(routineId: number, sportId: number, options?: any) {
        return SportsApiFp(this.configuration).dissociateRoutineSport(routineId, sportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve sports
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static findSports(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail', direction?: 'asc' | 'desc', options?: any) {
        return SportsApiFp(this.configuration).findSports(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve sport
     * @param {number} sportId Sport identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static getSport(sportId: number, options?: any) {
        return SportsApiFp(this.configuration).getSport(sportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update sport
     * @param {number} sportId Sport identifier
     * @param {Sport} body Sport information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public static updateSport(sportId: number, body: Sport, options?: any) {
        return SportsApiFp(this.configuration).updateSport(sportId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create current user weighting
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWeighting(body: Weighting, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addWeighting.');
            }
            const localVarPath = `/user/current/weightings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Weighting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create user
         * @param {User} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options: any = {}): FetchArgs {
            const localVarPath = `/user/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWeighting(weightingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'weightingId' is not null or undefined
            if (weightingId === null || weightingId === undefined) {
                throw new RequiredError('weightingId','Required parameter weightingId was null or undefined when calling deleteWeighting.');
            }
            const localVarPath = `/user/current/weightings/{weightingId}`
                .replace(`{${"weightingId"}}`, encodeURIComponent(String(weightingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutine(routineId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling favRoutine.');
            }
            const localVarPath = `/user/current/routines/{routineId}/favourites`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user favourite routines
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutines(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/user/current/routines/favourites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user routines
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentUserRoutines(difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/user/current/routines/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user routine executions
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutionsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/user/current/routines/executions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user routine ratings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatingsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/user/current/routines/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleWeighting(weightingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'weightingId' is not null or undefined
            if (weightingId === null || weightingId === undefined) {
                throw new RequiredError('weightingId','Required parameter weightingId was null or undefined when calling findSingleWeighting.');
            }
            const localVarPath = `/user/current/weightings/{weightingId}`
                .replace(`{${"weightingId"}}`, encodeURIComponent(String(weightingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve user routines
         * @param {number} userId User identifier
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserRoutines(userId: number, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling findUserRoutines.');
            }
            const localVarPath = `/user/{userId}/routines/`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user weightings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'weight' | 'height'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWeightings(page?: number, size?: number, orderBy?: 'id' | 'date' | 'weight' | 'height', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            const localVarPath = `/user/current/weightings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedUser(options: any = {}): FetchArgs {
            const localVarPath = `/user/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve other user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log user in
         * @param {Credentials} body User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: Credentials, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginUser.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log user out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options: any = {}): FetchArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend user verification email
         * @param {EmailResend} body Email resend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserVerificationEmail(body: EmailResend, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resendUserVerificationEmail.');
            }
            const localVarPath = `/user/resend_verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailResend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unmark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavRoutine(routineId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling unfavRoutine.');
            }
            const localVarPath = `/user/current/routines/{routineId}/favourites`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current user
         * @param {UserWithoutPassword} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserWithoutPassword, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserWithoutPassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user weighting
         * @param {number} weightingId Weighting identifier
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeighting(weightingId: number, body: Weighting, options: any = {}): FetchArgs {
            // verify required parameter 'weightingId' is not null or undefined
            if (weightingId === null || weightingId === undefined) {
                throw new RequiredError('weightingId','Required parameter weightingId was null or undefined when calling updateWeighting.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateWeighting.');
            }
            const localVarPath = `/user/current/weightings/{weightingId}`
                .replace(`{${"weightingId"}}`, encodeURIComponent(String(weightingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Weighting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify user email
         * @param {EmailConfirmation} body Email confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserEmail(body: EmailConfirmation, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyUserEmail.');
            }
            const localVarPath = `/user/verify_email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailConfirmation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create current user weighting
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWeighting(body: Weighting, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullWeighting> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).addWeighting(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Create user
         * @param {User} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWeighting(weightingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteWeighting(weightingId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Mark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutine(routineId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).favRoutine(routineId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user favourite routines
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutines(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Favourites> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).favRoutines(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user routines
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentUserRoutines(difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Routines> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findCurrentUserRoutines(difficulty, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user routine executions
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutionsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Executions> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findExecutionsForUser(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user routine ratings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatingsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ratings> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findRatingsForUser(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleWeighting(weightingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findSingleWeighting(weightingId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve user routines
         * @param {number} userId User identifier
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserRoutines(userId: number, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Routines> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findUserRoutines(userId, difficulty, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user weightings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'weight' | 'height'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWeightings(page?: number, size?: number, orderBy?: 'id' | 'date' | 'weight' | 'height', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Weightings> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findWeightings(page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getLoggedUser(options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve other user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserById(userId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Log user in
         * @param {Credentials} body User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: Credentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthenticationToken> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).loginUser(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Log user out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).logoutUser(options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Resend user verification email
         * @param {EmailResend} body Email resend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserVerificationEmail(body: EmailResend, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).resendUserVerificationEmail(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Unmark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavRoutine(routineId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).unfavRoutine(routineId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update current user
         * @param {UserWithoutPassword} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserWithoutPassword, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update user weighting
         * @param {number} weightingId Weighting identifier
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeighting(weightingId: number, body: Weighting, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateWeighting(weightingId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Verify user email
         * @param {EmailConfirmation} body Email confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserEmail(body: EmailConfirmation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).verifyUserEmail(body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create current user weighting
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWeighting(body: Weighting, options?: any) {
            return UsersApiFp(configuration).addWeighting(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create user
         * @param {User} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any) {
            return UsersApiFp(configuration).deleteUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWeighting(weightingId: number, options?: any) {
            return UsersApiFp(configuration).deleteWeighting(weightingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutine(routineId: number, options?: any) {
            return UsersApiFp(configuration).favRoutine(routineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user favourite routines
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favRoutines(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).favRoutines(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user routines
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentUserRoutines(difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).findCurrentUserRoutines(difficulty, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user routine executions
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExecutionsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).findExecutionsForUser(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user routine ratings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'score'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRatingsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).findRatingsForUser(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user weighting
         * @param {number} weightingId Weighting identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleWeighting(weightingId: number, options?: any) {
            return UsersApiFp(configuration).findSingleWeighting(weightingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve user routines
         * @param {number} userId User identifier
         * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserRoutines(userId: number, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).findUserRoutines(userId, difficulty, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user weightings
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'date' | 'weight' | 'height'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWeightings(page?: number, size?: number, orderBy?: 'id' | 'date' | 'weight' | 'height', direction?: 'asc' | 'desc', options?: any) {
            return UsersApiFp(configuration).findWeightings(page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedUser(options?: any) {
            return UsersApiFp(configuration).getLoggedUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve other user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any) {
            return UsersApiFp(configuration).getUserById(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Log user in
         * @param {Credentials} body User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: Credentials, options?: any) {
            return UsersApiFp(configuration).loginUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Log user out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any) {
            return UsersApiFp(configuration).logoutUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resend user verification email
         * @param {EmailResend} body Email resend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserVerificationEmail(body: EmailResend, options?: any) {
            return UsersApiFp(configuration).resendUserVerificationEmail(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unmark current user routine as favourite
         * @param {number} routineId Routine identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavRoutine(routineId: number, options?: any) {
            return UsersApiFp(configuration).unfavRoutine(routineId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update current user
         * @param {UserWithoutPassword} body User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserWithoutPassword, options?: any) {
            return UsersApiFp(configuration).updateUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user weighting
         * @param {number} weightingId Weighting identifier
         * @param {Weighting} body Weighting information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeighting(weightingId: number, body: Weighting, options?: any) {
            return UsersApiFp(configuration).updateWeighting(weightingId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Verify user email
         * @param {EmailConfirmation} body Email confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserEmail(body: EmailConfirmation, options?: any) {
            return UsersApiFp(configuration).verifyUserEmail(body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create current user weighting
     * @param {Weighting} body Weighting information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static addWeighting(body: Weighting, options?: any) {
        return UsersApiFp(this.configuration).addWeighting(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create user
     * @param {User} body User information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static createUser(body: User, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static deleteUser(options?: any) {
        return UsersApiFp(this.configuration).deleteUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete user weighting
     * @param {number} weightingId Weighting identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static deleteWeighting(weightingId: number, options?: any) {
        return UsersApiFp(this.configuration).deleteWeighting(weightingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark current user routine as favourite
     * @param {number} routineId Routine identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static favRoutine(routineId: number, options?: any) {
        return UsersApiFp(this.configuration).favRoutine(routineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user favourite routines
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static favRoutines(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).favRoutines(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user routines
     * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findCurrentUserRoutines(difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).findCurrentUserRoutines(difficulty, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user routine executions
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'duration' | 'wasModified'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findExecutionsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'duration' | 'wasModified', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).findExecutionsForUser(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user routine ratings
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'score'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findRatingsForUser(page?: number, size?: number, orderBy?: 'id' | 'date' | 'score', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).findRatingsForUser(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user weighting
     * @param {number} weightingId Weighting identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findSingleWeighting(weightingId: number, options?: any) {
        return UsersApiFp(this.configuration).findSingleWeighting(weightingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve user routines
     * @param {number} userId User identifier
     * @param {'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert'} [difficulty] Difficulty level
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findUserRoutines(userId: number, difficulty?: 'rookie' | 'beginner' | 'intermediate' | 'advanced' | 'expert', page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'dateCreated' | 'averageRating' | 'difficulty' | 'categoryId' | 'creatorId', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).findUserRoutines(userId, difficulty, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user weightings
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'date' | 'weight' | 'height'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static findWeightings(page?: number, size?: number, orderBy?: 'id' | 'date' | 'weight' | 'height', direction?: 'asc' | 'desc', options?: any) {
        return UsersApiFp(this.configuration).findWeightings(page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static getLoggedUser(options?: any) {
        return UsersApiFp(this.configuration).getLoggedUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve other user
     * @param {number} userId User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static getUserById(userId: number, options?: any) {
        return UsersApiFp(this.configuration).getUserById(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Log user in
     * @param {Credentials} body User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static async loginUser(body: Credentials, options?: any) {
        const auth = await UsersApiFp(this.configuration).loginUser(body, options)(this.fetch, this.basePath);
        window.localStorage.setItem(TOKEN_STORAGE, `bearer ${auth.token}`);
    }

    /**
     * 
     * @summary Log user out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static async logoutUser(options?: any) {
        const response = await UsersApiFp(this.configuration).logoutUser(options)(this.fetch, this.basePath);
        return response;
    }

    /**
     * 
     * @summary Resend user verification email
     * @param {EmailResend} body Email resend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static resendUserVerificationEmail(body: EmailResend, options?: any) {
        return UsersApiFp(this.configuration).resendUserVerificationEmail(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unmark current user routine as favourite
     * @param {number} routineId Routine identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static unfavRoutine(routineId: number, options?: any) {
        return UsersApiFp(this.configuration).unfavRoutine(routineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update current user
     * @param {UserWithoutPassword} body User information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static updateUser(body: UserWithoutPassword, options?: any) {
        return UsersApiFp(this.configuration).updateUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user weighting
     * @param {number} weightingId Weighting identifier
     * @param {Weighting} body Weighting information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static updateWeighting(weightingId: number, body: Weighting, options?: any) {
        return UsersApiFp(this.configuration).updateWeighting(weightingId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Verify user email
     * @param {EmailConfirmation} body Email confirmation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public static verifyUserEmail(body: EmailConfirmation, options?: any) {
        return UsersApiFp(this.configuration).verifyUserEmail(body, options)(this.fetch, this.basePath);
    }

    private static async createLibraryExercises() {
        const categories = (await CategoriesApi.findCategories()).results.filter(c => c.name == "None");
        const category = categories.length > 0 ? categories[0] : await CategoriesApi.addCategory({name: "None"});

        const routine = await RoutinesApi.addRoutine({
            name: EXERCISE_LIBRARY_NAME,
            detail: "",
            isPublic: false,
            category: category,
            difficulty: Routine.DifficultyEnum.Rookie
        });
        const cycle = await CyclesApi.addCycle(routine.id, {
            name: "",
            detail: "",
            order: 1,
            repetitions: 1,
            type: Cycle.TypeEnum.Cooldown
        });

        const exercises = await Promise.all(defaultExercises.map(e => ExercisesApi.addExercise(routine.id, cycle.id, e)));
        await Promise.all(defaultExercisesImages.map((image, i) => ImagesApi.addExerciseImage(routine.id, cycle.id, exercises[i].id, image)))

        return { routine: routine, cycle: cycle };
    }

    public static async getExerciseLibrary() {
        const routines = (await this.findCurrentUserRoutines("rookie", undefined, 9999, "id", "asc")).results.filter(r => r.name == EXERCISE_LIBRARY_NAME);
        if(routines.length > 0) {
            const routine = routines[0];
            const cycle = (await CyclesApi.findCycles(routine.id)).results[0];
            return { cycle: cycle, routine: routine};
        }
        else return this.createLibraryExercises();
    }

    public static async findLibraryExercises(page?: number, size?: number, orderBy?: 'id' | 'name' | 'detail' | 'type' | 'repetitions' | 'duration', direction?: 'asc' | 'desc', options?: any) : Promise<FullExerciseImageCombo[]> {
        const library = await this.getExerciseLibrary();

        const exercises = (await ExercisesApi.findExercises(library.routine.id, library.cycle.id, page, size, orderBy, direction, options)).results;
        return await Promise.all(exercises.map(async e => {
            const images = (await ImagesApi.findExerciseImages(library.routine.id, library.cycle.id, e.id)).results;
            return { exercise: e, image: (images.length > 0 ? images[0] : null)} as FullExerciseImageCombo;
          }));
    }

    public static async addLibraryExercise(exercise: Exercise, image?: Image): Promise<FullExerciseImageCombo>{
        const library = await this.getExerciseLibrary();

        const exc = ExercisesApi.addExercise(library.routine.id, library.cycle.id, exercise);
        let img = null;
        if(image) {
            img = await ImagesApi.addExerciseImage(library.routine.id, library.cycle.id, (await exc).id, image);
        }
        return { exercise: await exc, image: img};
    }

    public static async deleteLibraryExercise(exerciseId: number) {
        const library = await this.getExerciseLibrary();

        return ExercisesApi.deleteExercise(library.routine.id, library.cycle.id, exerciseId);
    }

    public static async updateLibraryExercise(exerciseId: number, exercise: Exercise) {
        const library = await this.getExerciseLibrary();

        return ExercisesApi.updateExercise(library.routine.id, library.cycle.id, exerciseId, exercise);
    }
}

/**
 * VideosApi - fetch parameter creator
 * @export
 */
export const VideosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseVideo(routineId: number, cycleId: number, exerciseId: number, body: Video, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling addExerciseVideo.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling addExerciseVideo.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling addExerciseVideo.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addExerciseVideo.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/videos`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Video" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling deleteExerciseVideo.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling deleteExerciseVideo.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling deleteExerciseVideo.');
            }
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling deleteExerciseVideo.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/videos/{videoId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise videos
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseVideos(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findExerciseVideos.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findExerciseVideos.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling findExerciseVideos.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/videos`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling findSingleExerciseVideo.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling findSingleExerciseVideo.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling findSingleExerciseVideo.');
            }
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling findSingleExerciseVideo.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/videos/{videoId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, body: Video, options: any = {}): FetchArgs {
            // verify required parameter 'routineId' is not null or undefined
            if (routineId === null || routineId === undefined) {
                throw new RequiredError('routineId','Required parameter routineId was null or undefined when calling updateExerciseVideo.');
            }
            // verify required parameter 'cycleId' is not null or undefined
            if (cycleId === null || cycleId === undefined) {
                throw new RequiredError('cycleId','Required parameter cycleId was null or undefined when calling updateExerciseVideo.');
            }
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling updateExerciseVideo.');
            }
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling updateExerciseVideo.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExerciseVideo.');
            }
            const localVarPath = `/routines/{routineId}/cycles/{cycleId}/exercises/{exerciseId}/videos/{videoId}`
                .replace(`{${"routineId"}}`, encodeURIComponent(String(routineId)))
                .replace(`{${"cycleId"}}`, encodeURIComponent(String(cycleId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Video" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseVideo(routineId: number, cycleId: number, exerciseId: number, body: Video, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullVideo> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).addExerciseVideo(routineId, cycleId, exerciseId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Delete routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).deleteExerciseVideo(routineId, cycleId, exerciseId, videoId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise videos
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseVideos(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Videos> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).findExerciseVideos(routineId, cycleId, exerciseId, page, size, orderBy, direction, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullVideo> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).findSingleExerciseVideo(routineId, cycleId, exerciseId, videoId, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
        /**
         * 
         * @summary Update routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, body: Video, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullVideo> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).updateExerciseVideo(routineId, cycleId, exerciseId, videoId, body, options);
            return async (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options);
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            };
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExerciseVideo(routineId: number, cycleId: number, exerciseId: number, body: Video, options?: any) {
            return VideosApiFp(configuration).addExerciseVideo(routineId, cycleId, exerciseId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any) {
            return VideosApiFp(configuration).deleteExerciseVideo(routineId, cycleId, exerciseId, videoId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise videos
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} [page] Page number
         * @param {number} [size] Items per page
         * @param {'id' | 'number' | 'url'} [orderBy] Order by
         * @param {'asc' | 'desc'} [direction] Order direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExerciseVideos(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any) {
            return VideosApiFp(configuration).findExerciseVideos(routineId, cycleId, exerciseId, page, size, orderBy, direction, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSingleExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any) {
            return VideosApiFp(configuration).findSingleExerciseVideo(routineId, cycleId, exerciseId, videoId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update routine cycle exercise video
         * @param {number} routineId Routine identifier
         * @param {number} cycleId Cycle identifier
         * @param {number} exerciseId Exercise identifier
         * @param {number} videoId Video identifier
         * @param {Video} body Video information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, body: Video, options?: any) {
            return VideosApiFp(configuration).updateExerciseVideo(routineId, cycleId, exerciseId, videoId, body, options)(fetch, basePath);
        },
    };
};

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * 
     * @summary Create routine cycle exercise video
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {Video} body Video information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public static addExerciseVideo(routineId: number, cycleId: number, exerciseId: number, body: Video, options?: any) {
        return VideosApiFp(this.configuration).addExerciseVideo(routineId, cycleId, exerciseId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete routine cycle exercise video
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} videoId Video identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public static deleteExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any) {
        return VideosApiFp(this.configuration).deleteExerciseVideo(routineId, cycleId, exerciseId, videoId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercise videos
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} [page] Page number
     * @param {number} [size] Items per page
     * @param {'id' | 'number' | 'url'} [orderBy] Order by
     * @param {'asc' | 'desc'} [direction] Order direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public static findExerciseVideos(routineId: number, cycleId: number, exerciseId: number, page?: number, size?: number, orderBy?: 'id' | 'number' | 'url', direction?: 'asc' | 'desc', options?: any) {
        return VideosApiFp(this.configuration).findExerciseVideos(routineId, cycleId, exerciseId, page, size, orderBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve routine cycle exercise video
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} videoId Video identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public static findSingleExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, options?: any) {
        return VideosApiFp(this.configuration).findSingleExerciseVideo(routineId, cycleId, exerciseId, videoId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update routine cycle exercise video
     * @param {number} routineId Routine identifier
     * @param {number} cycleId Cycle identifier
     * @param {number} exerciseId Exercise identifier
     * @param {number} videoId Video identifier
     * @param {Video} body Video information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public static updateExerciseVideo(routineId: number, cycleId: number, exerciseId: number, videoId: number, body: Video, options?: any) {
        return VideosApiFp(this.configuration).updateExerciseVideo(routineId, cycleId, exerciseId, videoId, body, options)(this.fetch, this.basePath);
    }

}

const defaultExercises: Exercise[] = [
    {
      name: "Plancha",
      detail: "",
      duration: 30,
      repetitions: 0,
      type: Exercise.TypeEnum.Exercise,
      order: 1
    },
    {
      name: "Push-up",
      detail: "",
      duration: 0,
      repetitions: 15,
      type: Exercise.TypeEnum.Exercise,
      order: 2,
    },
    {
      name: "Sentadilla",
      detail: "",
      duration: 0,
      repetitions: 10,
      type: Exercise.TypeEnum.Exercise,
      order: 3,
    },
];

const defaultExercisesImages: Image[] = [
{
    number: 1,
    url: "https://www.t-nation.com/system/publishing/articles/10001096/original/Unconventional-Workout-Abs.jpg?1515713332"
},
{
    number: 1,
    url: "https://lmimirror3pvr.azureedge.net/static/media/12867/2d5a7ea5-1c56-40e1-aba6-dbbfe959f35a/pushup-study_960x540.jpg"
},
{
    number: 1,
    url: "https://www.inposture.com/wp-content/uploads/2020/05/Sit-ups.jpg"
}];
